#define private public
#include <aes_cpp/aes.hpp>
#undef private
#include <aes_cpp/aes_utils.hpp>
#include <algorithm>
#include <array>
#include <atomic>
#include <chrono>
#include <future>
#include <iostream>
#include <string>
#include <thread>
#include <vector>

#include "gtest/gtest.h"

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4996)
#endif

const unsigned int BLOCK_BYTES_LENGTH = 16 * sizeof(unsigned char);

namespace aes_cpp {
bool constant_time_eq(const unsigned char *a, const unsigned char *b,
                      size_t len);
}

TEST(Internal, ConstantTimeEq) {
  unsigned char a[] = {0x00, 0x01, 0x02, 0x03};
  unsigned char b[] = {0x00, 0x01, 0x02, 0x03};
  unsigned char c[] = {0x00, 0x01, 0x02, 0x04};
  // Equal buffers must compare as equal.
  EXPECT_TRUE(aes_cpp::constant_time_eq(a, b, sizeof(a)));
  // A differing byte must result in inequality.
  EXPECT_FALSE(aes_cpp::constant_time_eq(a, c, sizeof(a)));
}

TEST(Internal, PrepareRoundKeysRecomputesAfterManualClear) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  const std::array<unsigned char, 16> key = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
                                             0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
                                             0x0c, 0x0d, 0x0e, 0x0f};

  auto primed = aes.prepare_round_keys(key.data());
  ASSERT_NE(primed, nullptr);

  aes.cachedRoundKeys.reset();
  ASSERT_FALSE(aes.cachedRoundKeys);

  auto regenerated = aes.prepare_round_keys(key.data());
  EXPECT_NE(regenerated, nullptr);
}

TEST(Internal, ConcurrentKeyPreparationDoesNotAffectEncryption) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
  unsigned char key1[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                          0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};
  unsigned char key2[] = {0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
                          0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};
  auto roundKeys = aes.prepare_round_keys(key1);

  std::promise<void> ready;
  std::atomic<bool> go{false};
  std::array<unsigned char, 16> out;

  std::thread t([&]() {
    ready.set_value();
    while (!go.load()) {
    }
    aes.EncryptBlock(plain, out.data(), roundKeys->data());
  });

  ready.get_future().wait();
  aes.prepare_round_keys(key2);
  go = true;
  t.join();

  unsigned char expected[] = {0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30,
                              0xd8, 0xcd, 0xb7, 0x80, 0x70, 0xb4, 0xc5, 0x5a};
  ASSERT_FALSE(memcmp(expected, out.data(), sizeof(expected)));
}

TEST(KeyLengths, KeyLength128) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};
  unsigned char right[] = {0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30,
                           0xd8, 0xcd, 0xb7, 0x80, 0x70, 0xb4, 0xc5, 0x5a};
  unsigned char *out = aes.EncryptECB(plain, BLOCK_BYTES_LENGTH, key);

  ASSERT_FALSE(memcmp(right, out, BLOCK_BYTES_LENGTH));
  delete[] out;
}

TEST(KeyLengths, KeyLength192) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_192);
  unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17};
  unsigned char right[] = {0xdd, 0xa9, 0x7c, 0xa4, 0x86, 0x4c, 0xdf, 0xe0,
                           0x6e, 0xaf, 0x70, 0xa0, 0xec, 0x0d, 0x71, 0x91};

  unsigned char *out = aes.EncryptECB(plain, BLOCK_BYTES_LENGTH, key);
  ASSERT_FALSE(memcmp(right, out, BLOCK_BYTES_LENGTH));
  delete[] out;
}

TEST(KeyLengths, KeyLength256) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_256);
  unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
                         0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};
  unsigned char right[] = {0x8e, 0xa2, 0xb7, 0xca, 0x51, 0x67, 0x45, 0xbf,
                           0xea, 0xfc, 0x49, 0x90, 0x4b, 0x49, 0x60, 0x89};

  unsigned char *out = aes.EncryptECB(plain, BLOCK_BYTES_LENGTH, key);
  ASSERT_FALSE(memcmp(right, out, BLOCK_BYTES_LENGTH));
  delete[] out;
}

TEST(ECB, EncryptDecryptOneBlock) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_256);
  unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};

  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
                         0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};

  unsigned char *out = aes.EncryptECB(plain, BLOCK_BYTES_LENGTH, key);
  unsigned char *innew = aes.DecryptECB(out, BLOCK_BYTES_LENGTH, key);
  ASSERT_FALSE(memcmp(innew, plain, BLOCK_BYTES_LENGTH));
  delete[] out;
  delete[] innew;
}

TEST(ECB, EncryptDecryptVectorOneBlock) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_256);
  std::vector<unsigned char> plain = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
                                      0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb,
                                      0xcc, 0xdd, 0xee, 0xff};

  std::vector<unsigned char> key = {
      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
      0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
      0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};

  std::vector<unsigned char> out = aes.EncryptECB(plain, key);
  std::vector<unsigned char> innew = aes.DecryptECB(out, key);
  ASSERT_EQ(innew, plain);
}

TEST(ECB, OneBlockEncrypt) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};
  unsigned char right[] = {0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30,
                           0xd8, 0xcd, 0xb7, 0x80, 0x70, 0xb4, 0xc5, 0x5a};
  unsigned char *out = aes.EncryptECB(plain, BLOCK_BYTES_LENGTH, key);

  ASSERT_FALSE(memcmp(right, out, BLOCK_BYTES_LENGTH));

  delete[] out;
}

TEST(ECB, OneBlockEncryptVector) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  std::vector<unsigned char> plain = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
                                      0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb,
                                      0xcc, 0xdd, 0xee, 0xff};
  std::vector<unsigned char> key = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
                                    0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
                                    0x0c, 0x0d, 0x0e, 0x0f};
  std::vector<unsigned char> right = {0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b,
                                      0x04, 0x30, 0xd8, 0xcd, 0xb7, 0x80,
                                      0x70, 0xb4, 0xc5, 0x5a};
  std::vector<unsigned char> out = aes.EncryptECB(plain, key);

  ASSERT_EQ(right, out);
}

TEST(ECB, OneBlockWithoutByteEncrypt) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee};
  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};
  EXPECT_THROW(
      (void)aes.EncryptECB(
          plain, (BLOCK_BYTES_LENGTH - 1) * sizeof(unsigned char), key),
      std::length_error);
}

TEST(ECB, OneBlockPlusOneByteEncrypt) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
                           0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0xaa};
  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};

  EXPECT_THROW(
      (void)aes.EncryptECB(
          plain, (BLOCK_BYTES_LENGTH + 1) * sizeof(unsigned char), key),
      std::length_error);
}

TEST(ECB, TwoBlocksEncrypt) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
                           0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
                           0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};
  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};
  unsigned char right[] = {
      0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30, 0xd8, 0xcd, 0xb7,
      0x80, 0x70, 0xb4, 0xc5, 0x5a, 0x07, 0xfe, 0xef, 0x74, 0xe1, 0xd5,
      0x03, 0x6e, 0x90, 0x0e, 0xee, 0x11, 0x8e, 0x94, 0x92, 0x93,
  };
  unsigned char *out = aes.EncryptECB(plain, 2 * BLOCK_BYTES_LENGTH, key);

  ASSERT_FALSE(memcmp(right, out, 2 * BLOCK_BYTES_LENGTH));

  delete[] out;
}

TEST(ECB, OneBlockDecrypt) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char encrypted[] = {0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30,
                               0xd8, 0xcd, 0xb7, 0x80, 0x70, 0xb4, 0xc5, 0x5a};
  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};
  unsigned char right[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
  unsigned char *out = aes.DecryptECB(encrypted, BLOCK_BYTES_LENGTH, key);

  ASSERT_FALSE(memcmp(right, out, BLOCK_BYTES_LENGTH));

  delete[] out;
}

TEST(ECB, OneBlockDecryptVector) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  std::vector<unsigned char> encrypted = {0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b,
                                          0x04, 0x30, 0xd8, 0xcd, 0xb7, 0x80,
                                          0x70, 0xb4, 0xc5, 0x5a};
  std::vector<unsigned char> key = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
                                    0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
                                    0x0c, 0x0d, 0x0e, 0x0f};
  std::vector<unsigned char> right = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
                                      0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb,
                                      0xcc, 0xdd, 0xee, 0xff};
  std::vector<unsigned char> out = aes.DecryptECB(encrypted, key);

  ASSERT_EQ(right, out);
}

TEST(ECB, TwoBlocksDecrypt) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char encrypted[] = {
      0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30, 0xd8, 0xcd, 0xb7,
      0x80, 0x70, 0xb4, 0xc5, 0x5a, 0x07, 0xfe, 0xef, 0x74, 0xe1, 0xd5,
      0x03, 0x6e, 0x90, 0x0e, 0xee, 0x11, 0x8e, 0x94, 0x92, 0x93,
  };
  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};
  unsigned char right[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
                           0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
                           0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};
  unsigned char *out = aes.DecryptECB(encrypted, 2 * BLOCK_BYTES_LENGTH, key);

  ASSERT_FALSE(memcmp(right, out, 2 * BLOCK_BYTES_LENGTH));

  delete[] out;
}

TEST(CBC, EncryptDecrypt) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_256);
  unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
  unsigned char iv[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
                         0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};

  unsigned char *out = aes.EncryptCBC(plain, BLOCK_BYTES_LENGTH, key, iv);
  unsigned char *innew = aes.DecryptCBC(out, BLOCK_BYTES_LENGTH, key, iv);
  ASSERT_FALSE(memcmp(innew, plain, BLOCK_BYTES_LENGTH));
  delete[] out;
  delete[] innew;
}

TEST(CBC, EncryptDecryptVector) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_256);
  std::vector<unsigned char> plain = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
                                      0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb,
                                      0xcc, 0xdd, 0xee, 0xff};
  std::vector<unsigned char> iv = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                   0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                   0xff, 0xff, 0xff, 0xff};
  std::vector<unsigned char> key = {
      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
      0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
      0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};

  std::vector<unsigned char> out = aes.EncryptCBC(plain, key, iv);
  std::vector<unsigned char> innew = aes.DecryptCBC(out, key, iv);
  ASSERT_EQ(innew, plain);
}

TEST(CBC, TwoBlocksEncrypt) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
                           0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
  unsigned char iv[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};
  unsigned char right[] = {0x1b, 0x87, 0x23, 0x78, 0x79, 0x5f, 0x4f, 0xfd,
                           0x77, 0x28, 0x55, 0xfc, 0x87, 0xca, 0x96, 0x4d,
                           0x4c, 0x5b, 0xca, 0x1c, 0x48, 0xcd, 0x88, 0x00,
                           0x3a, 0x10, 0x52, 0x11, 0x88, 0x12, 0x5e, 0x00};

  unsigned char *out = aes.EncryptCBC(plain, 2 * BLOCK_BYTES_LENGTH, key, iv);
  ASSERT_FALSE(memcmp(out, right, 2 * BLOCK_BYTES_LENGTH));
  delete[] out;
}

TEST(CBC, TwoBlocksEncryptVector) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  std::vector<unsigned char> plain = {
      0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa,
      0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
      0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
  std::vector<unsigned char> iv = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                   0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                   0xff, 0xff, 0xff, 0xff};
  std::vector<unsigned char> key = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
                                    0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
                                    0x0c, 0x0d, 0x0e, 0x0f};
  std::vector<unsigned char> right = {
      0x1b, 0x87, 0x23, 0x78, 0x79, 0x5f, 0x4f, 0xfd, 0x77, 0x28, 0x55,
      0xfc, 0x87, 0xca, 0x96, 0x4d, 0x4c, 0x5b, 0xca, 0x1c, 0x48, 0xcd,
      0x88, 0x00, 0x3a, 0x10, 0x52, 0x11, 0x88, 0x12, 0x5e, 0x00};

  std::vector<unsigned char> out = aes.EncryptCBC(plain, key, iv);

  ASSERT_EQ(out, right);
}

TEST(CBC, TwoBlocksDecrypt) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char encrypted[] = {0x1b, 0x87, 0x23, 0x78, 0x79, 0x5f, 0x4f, 0xfd,
                               0x77, 0x28, 0x55, 0xfc, 0x87, 0xca, 0x96, 0x4d,
                               0x4c, 0x5b, 0xca, 0x1c, 0x48, 0xcd, 0x88, 0x00,
                               0x3a, 0x10, 0x52, 0x11, 0x88, 0x12, 0x5e, 0x00};

  unsigned char iv[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};
  unsigned char right[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
                           0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};

  unsigned char *out =
      aes.DecryptCBC(encrypted, 2 * BLOCK_BYTES_LENGTH, key, iv);

  ASSERT_FALSE(memcmp(out, right, 2 * BLOCK_BYTES_LENGTH));
  delete[] out;
}

TEST(CBC, TwoBlocksDecryptVector) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  std::vector<unsigned char> encrypted = {
      0x1b, 0x87, 0x23, 0x78, 0x79, 0x5f, 0x4f, 0xfd, 0x77, 0x28, 0x55,
      0xfc, 0x87, 0xca, 0x96, 0x4d, 0x4c, 0x5b, 0xca, 0x1c, 0x48, 0xcd,
      0x88, 0x00, 0x3a, 0x10, 0x52, 0x11, 0x88, 0x12, 0x5e, 0x00};

  std::vector<unsigned char> iv = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                   0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                   0xff, 0xff, 0xff, 0xff};
  std::vector<unsigned char> key = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
                                    0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
                                    0x0c, 0x0d, 0x0e, 0x0f};
  std::vector<unsigned char> right = {
      0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa,
      0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
      0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};

  std::vector<unsigned char> out = aes.DecryptCBC(encrypted, key, iv);

  ASSERT_EQ(out, right);
}

TEST(CBC, InPlaceDecrypt) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_256);
  unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
  unsigned char iv[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
  unsigned char ivCopy[BLOCK_BYTES_LENGTH];
  memcpy(ivCopy, iv, BLOCK_BYTES_LENGTH);
  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
                         0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};

  unsigned char *buf = aes.EncryptCBC(plain, BLOCK_BYTES_LENGTH, key, iv);
  aes.DecryptCBC(buf, BLOCK_BYTES_LENGTH, key, ivCopy, buf);
  ASSERT_FALSE(memcmp(buf, plain, BLOCK_BYTES_LENGTH));
  delete[] buf;
}

TEST(CFB, EncryptDecrypt) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_256);
  unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
  unsigned char iv[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
                         0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};

  unsigned char *out = aes.EncryptCFB(plain, BLOCK_BYTES_LENGTH, key, iv);
  unsigned char *innew = aes.DecryptCFB(out, BLOCK_BYTES_LENGTH, key, iv);
  ASSERT_FALSE(memcmp(innew, plain, BLOCK_BYTES_LENGTH));
  delete[] out;
  delete[] innew;
}

TEST(CFB, EncryptDecryptVector) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_256);
  std::vector<unsigned char> plain = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
                                      0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb,
                                      0xcc, 0xdd, 0xee, 0xff};
  std::vector<unsigned char> iv = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                   0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                   0xff, 0xff, 0xff, 0xff};
  std::vector<unsigned char> key = {
      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
      0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
      0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};

  std::vector<unsigned char> out = aes.EncryptCFB(plain, key, iv);
  std::vector<unsigned char> innew = aes.DecryptCFB(out, key, iv);
  ASSERT_EQ(innew, plain);
}

TEST(CFB, EncryptTwoBlocks) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
                           0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
  unsigned char iv[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};
  unsigned char right[] = {0x3c, 0x55, 0x3d, 0x01, 0x8a, 0x52, 0xe4, 0x54,
                           0xec, 0x4e, 0x08, 0x22, 0xc2, 0x8d, 0x55, 0xec,
                           0xe3, 0x5a, 0x40, 0xab, 0x30, 0x29, 0xf3, 0x0c,
                           0xe1, 0xdb, 0x30, 0x6c, 0xa1, 0x05, 0xcb, 0xa9};

  unsigned char *out = aes.EncryptCFB(plain, 2 * BLOCK_BYTES_LENGTH, key, iv);
  ASSERT_FALSE(memcmp(right, out, 2 * BLOCK_BYTES_LENGTH));
  delete[] out;
}

TEST(CFB, EncryptTwoBlocksVector) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  std::vector<unsigned char> plain = {
      0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa,
      0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
      0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
  std::vector<unsigned char> iv = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                   0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                   0xff, 0xff, 0xff, 0xff};
  std::vector<unsigned char> key = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
                                    0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
                                    0x0c, 0x0d, 0x0e, 0x0f};
  std::vector<unsigned char> right = {
      0x3c, 0x55, 0x3d, 0x01, 0x8a, 0x52, 0xe4, 0x54, 0xec, 0x4e, 0x08,
      0x22, 0xc2, 0x8d, 0x55, 0xec, 0xe3, 0x5a, 0x40, 0xab, 0x30, 0x29,
      0xf3, 0x0c, 0xe1, 0xdb, 0x30, 0x6c, 0xa1, 0x05, 0xcb, 0xa9};

  std::vector<unsigned char> out = aes.EncryptCFB(plain, key, iv);
  ASSERT_EQ(right, out);
}

TEST(CFB, DecryptTwoBlocks) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  std::vector<unsigned char> encrypted = {
      0x3c, 0x55, 0x3d, 0x01, 0x8a, 0x52, 0xe4, 0x54, 0xec, 0x4e, 0x08,
      0x22, 0xc2, 0x8d, 0x55, 0xec, 0xe3, 0x5a, 0x40, 0xab, 0x30, 0x29,
      0xf3, 0x0c, 0xe1, 0xdb, 0x30, 0x6c, 0xa1, 0x05, 0xcb, 0xa9};
  std::vector<unsigned char> iv = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                   0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                   0xff, 0xff, 0xff, 0xff};
  std::vector<unsigned char> key = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
                                    0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
                                    0x0c, 0x0d, 0x0e, 0x0f};
  std::vector<unsigned char> right = {
      0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa,
      0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
      0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};

  std::vector<unsigned char> out = aes.DecryptCFB(encrypted, key, iv);
  ASSERT_EQ(right, out);
}

TEST(CFB, DecryptTwoBlocksVector) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char encrypted[] = {0x3c, 0x55, 0x3d, 0x01, 0x8a, 0x52, 0xe4, 0x54,
                               0xec, 0x4e, 0x08, 0x22, 0xc2, 0x8d, 0x55, 0xec,
                               0xe3, 0x5a, 0x40, 0xab, 0x30, 0x29, 0xf3, 0x0c,
                               0xe1, 0xdb, 0x30, 0x6c, 0xa1, 0x05, 0xcb, 0xa9};
  unsigned char iv[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};
  unsigned char right[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
                           0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};

  unsigned char *out =
      aes.DecryptCFB(encrypted, 2 * BLOCK_BYTES_LENGTH, key, iv);
  ASSERT_FALSE(memcmp(right, out, 2 * BLOCK_BYTES_LENGTH));
  delete[] out;
}

TEST(CFB, InPlaceDecrypt) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_256);
  unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
  unsigned char iv[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
  unsigned char ivCopy[BLOCK_BYTES_LENGTH];
  memcpy(ivCopy, iv, BLOCK_BYTES_LENGTH);
  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
                         0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};

  unsigned char *buf = aes.EncryptCFB(plain, BLOCK_BYTES_LENGTH, key, iv);
  aes.DecryptCFB(buf, BLOCK_BYTES_LENGTH, key, ivCopy, buf);
  ASSERT_FALSE(memcmp(buf, plain, BLOCK_BYTES_LENGTH));
  delete[] buf;
}

TEST(LongData, EncryptDecryptOneKb) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_256);
  unsigned int kbSize = 1024 * sizeof(unsigned char);
  unsigned char *plain = new unsigned char[kbSize];
  for (unsigned int i = 0; i < kbSize; i++) {
    plain[i] = i % 256;
  }

  unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                         0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
                         0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};

  unsigned char *out = aes.EncryptECB(plain, kbSize, key);
  unsigned char *innew = aes.DecryptECB(out, kbSize, key);
  ASSERT_FALSE(memcmp(innew, plain, kbSize));
  delete[] plain;
  delete[] out;
  delete[] innew;
}

TEST(LongData, EncryptDecryptVectorOneKb) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_256);
  unsigned int kbSize = 1024 * sizeof(unsigned char);
  std::vector<unsigned char> plain(kbSize);
  for (unsigned int i = 0; i < kbSize; i++) {
    plain[i] = i % 256;
  }

  std::vector<unsigned char> key = {
      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
      0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
      0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};

  std::vector<unsigned char> out = aes.EncryptECB(plain, key);
  std::vector<unsigned char> innew = aes.DecryptECB(out, key);
  ASSERT_EQ(innew, plain);
}

TEST(CTR, CounterOverflowThrows) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char plain[16] = {0};
  unsigned char key[16] = {0};
  unsigned char iv[16];
  std::fill_n(iv, sizeof(iv), 0xFF);
  unsigned char out[16];
  EXPECT_THROW(aes.EncryptCTR(plain, sizeof(plain), key, iv, out),
               std::length_error);
}

TEST(GCM, EncryptDecryptZeroPlaintext) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char key[16] = {0};
  unsigned char iv[12] = {0};
  unsigned char tag[16];
  EXPECT_NO_THROW({
    aes.EncryptGCM(nullptr, 0, key, iv, nullptr, 0, tag, nullptr);
    aes.DecryptGCM(nullptr, 0, key, iv, nullptr, 0, tag, nullptr);
  });
}

TEST(GCM, DecryptInvalidTag) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char plain[16] = {0};
  unsigned char key[16] = {0};
  unsigned char iv[12] = {0};
  unsigned char tag[16] = {0};

  unsigned char *cipher =
      aes.EncryptGCM(plain, sizeof(plain), key, iv, nullptr, 0, tag);
  tag[0] ^= 0x01;  // Corrupt the tag

  EXPECT_THROW(
      {
        unsigned char *out =
            aes.DecryptGCM(cipher, sizeof(plain), key, iv, nullptr, 0, tag);
        delete[] out;
      },
      std::runtime_error);

  delete[] cipher;
}

TEST(GCM, DecryptInPlace) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char plain[32];
  for (size_t i = 0; i < sizeof(plain); ++i) {
    plain[i] = static_cast<unsigned char>(i);
  }
  unsigned char key[16] = {0};
  unsigned char iv[12] = {0};
  unsigned char tag[16];
  unsigned char buffer[sizeof(plain)];

  aes.EncryptGCM(plain, sizeof(plain), key, iv, nullptr, 0, tag, buffer);
  aes.DecryptGCM(buffer, sizeof(buffer), key, iv, nullptr, 0, tag, buffer);

  ASSERT_FALSE(memcmp(buffer, plain, sizeof(plain)));
}

TEST(GCM, InputTooLong) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char in[16] = {0};
  unsigned char out[16];
  unsigned char key[16] = {0};
  unsigned char iv[12] = {0};
  unsigned char tag[16] = {0};
  size_t tooLong = ((1ULL << 32) * 16) + 1;

  EXPECT_THROW(aes.EncryptGCM(in, tooLong, key, iv, nullptr, 0, tag, out),
               std::length_error);

  EXPECT_THROW(aes.DecryptGCM(in, tooLong, key, iv, nullptr, 0, tag, out),
               std::length_error);
}

TEST(GCM, AadTooLong) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char in = 0;
  unsigned char out;
  unsigned char aad = 0;
  std::array<unsigned char, 16> key{};
  std::array<unsigned char, 12> iv{};
  std::array<unsigned char, 16> tag{};
  const size_t gcmByteLimit = ((1ULL << 39) - 256) / 8;

  EXPECT_THROW(aes.EncryptGCM(&in, 0, key.data(), iv.data(), &aad,
                              gcmByteLimit + 1, tag.data(), &out),
               std::length_error);

  EXPECT_THROW(aes.DecryptGCM(&in, 0, key.data(), iv.data(), &aad,
                              gcmByteLimit + 1, tag.data(), &out),
               std::length_error);
}

TEST(GCM, AadPlusInputTooLong) {
  aes_cpp::AES aes(aes_cpp::AESKeyLength::AES_128);
  unsigned char in = 0;
  unsigned char out;
  unsigned char aad = 0;
  std::array<unsigned char, 16> key{};
  std::array<unsigned char, 12> iv{};
  std::array<unsigned char, 16> tag{};
  const size_t gcmByteLimit = ((1ULL << 39) - 256) / 8;

  EXPECT_THROW(aes.EncryptGCM(&in, 1, key.data(), iv.data(), &aad, gcmByteLimit,
                              tag.data(), &out),
               std::length_error);

  EXPECT_THROW(aes.DecryptGCM(&in, 1, key.data(), iv.data(), &aad, gcmByteLimit,
                              tag.data(), &out),
               std::length_error);
}

TEST(Utils, EncryptDecryptStringCBC) {
  std::string text = "hello world";
  std::array<uint8_t, 16> key = {0};
  auto enc = aes_cpp::utils::encrypt(text, key, aes_cpp::utils::AesMode::CBC);
  std::string dec =
      aes_cpp::utils::decrypt_to_string(enc, key, aes_cpp::utils::AesMode::CBC);
  ASSERT_EQ(text, dec);
}

TEST(Utils, DecryptStringCbcInvalidPadding) {
  std::string text = "hello world";
  std::array<uint8_t, 16> key = {0};
  auto enc = aes_cpp::utils::encrypt(text, key, aes_cpp::utils::AesMode::CBC);
  enc.iv.back() ^= 0x01;
  EXPECT_THROW(aes_cpp::utils::decrypt(enc, key, aes_cpp::utils::AesMode::CBC),
               std::runtime_error);
}

TEST(Utils, DecryptStringCbcMalformedCiphertextsSameError) {
  std::string text = "hello world";
  std::array<uint8_t, 16> key = {0};
  auto enc = aes_cpp::utils::encrypt(text, key, aes_cpp::utils::AesMode::CBC);

  auto bad_padding = enc;
  bad_padding.iv.back() ^= 0x01;

  auto bad_length = enc;
  bad_length.ciphertext.pop_back();

  std::string pad_msg;
  try {
    aes_cpp::utils::decrypt(bad_padding, key, aes_cpp::utils::AesMode::CBC);
    FAIL() << "Expected runtime_error";
  } catch (const std::runtime_error &e) {
    pad_msg = e.what();
  }

  std::string len_msg;
  try {
    aes_cpp::utils::decrypt(bad_length, key, aes_cpp::utils::AesMode::CBC);
    FAIL() << "Expected runtime_error";
  } catch (const std::runtime_error &e) {
    len_msg = e.what();
  }

  EXPECT_EQ(pad_msg, len_msg);
}

TEST(Utils, ExtractIvFromCiphertextTooShort) {
  std::vector<uint8_t> ciphertext_with_iv(aes_cpp::utils::BLOCK_SIZE - 1, 0);
  std::array<uint8_t, aes_cpp::utils::BLOCK_SIZE> iv;
  EXPECT_THROW(
      aes_cpp::utils::extract_iv_from_ciphertext(ciphertext_with_iv, iv),
      std::invalid_argument);
}

TEST(Utils, ConstantTimeEqual) {
  std::vector<uint8_t> a = {0x00, 0x01, 0x02, 0x03};
  auto b = a;
  std::vector<uint8_t> c = {0x00, 0x01, 0x02, 0x04};
  EXPECT_TRUE(aes_cpp::utils::constant_time_equal(a, b));
  EXPECT_FALSE(aes_cpp::utils::constant_time_equal(a, c));
}

TEST(Utils, RemovePaddingConstantTime) {
  std::vector<uint8_t> valid(aes_cpp::utils::BLOCK_SIZE,
                             static_cast<uint8_t>(aes_cpp::utils::BLOCK_SIZE));
  auto invalid = valid;
  invalid.back() = 0;

  std::vector<uint8_t> out;
  std::size_t out_len;

  EXPECT_TRUE(aes_cpp::utils::remove_padding(valid, out, out_len));
  EXPECT_EQ(out_len, 0U);

  EXPECT_FALSE(aes_cpp::utils::remove_padding(invalid, out, out_len));
  EXPECT_EQ(out_len, invalid.size());
}

TEST(Utils, EncryptDecryptCtrZeroLength) {
  std::vector<uint8_t> plain;
  std::array<uint8_t, 16> key = {0};
  auto enc = aes_cpp::utils::encrypt(plain, key, aes_cpp::utils::AesMode::CTR);
  auto dec = aes_cpp::utils::decrypt(enc, key, aes_cpp::utils::AesMode::CTR);
  ASSERT_EQ(dec, plain);
}

TEST(Utils, EncryptDecryptCtrNonBlockSize) {
  std::vector<uint8_t> plain = {'n', 'o', 'n', 'b', 'l', 'o', 'c', 'k'};
  std::array<uint8_t, 16> key = {0};
  auto enc = aes_cpp::utils::encrypt(plain, key, aes_cpp::utils::AesMode::CTR);
  auto dec = aes_cpp::utils::decrypt(enc, key, aes_cpp::utils::AesMode::CTR);
  ASSERT_EQ(dec, plain);
}

TEST(Utils, EncryptDecryptStringGCM) {
  std::string text = "hello gcm";
  std::array<uint8_t, 16> key = {0};
  auto enc = aes_cpp::utils::encrypt_gcm(text, key);
  std::string dec = aes_cpp::utils::decrypt_gcm_to_string(enc, key);
  ASSERT_EQ(text, dec);
}

TEST(Utils, EncryptDecryptStringGCMWithAad) {
  std::string text = "hello gcm";
  std::array<uint8_t, 16> key = {0};
  std::vector<uint8_t> aad = {1, 2, 3};
  auto enc = aes_cpp::utils::encrypt_gcm(text, key, aad);
  std::string dec = aes_cpp::utils::decrypt_gcm_to_string(enc, key, aad);
  ASSERT_EQ(text, dec);
}

TEST(Utils, DecryptStringGcmTagMismatch) {
  std::string text = "hello gcm";
  std::array<uint8_t, 16> key = {0};
  auto enc = aes_cpp::utils::encrypt_gcm(text, key);
  enc.tag[0] ^= 0x01;
  EXPECT_THROW(aes_cpp::utils::decrypt_gcm(enc, key), std::runtime_error);
}

TEST(Utils, DecryptStringGcmCiphertextMismatch) {
  std::string text = "hello gcm";
  std::array<uint8_t, 16> key = {0};
  auto enc = aes_cpp::utils::encrypt_gcm(text, key);
  enc.ciphertext[0] ^= 0x01;
  EXPECT_THROW(aes_cpp::utils::decrypt_gcm(enc, key), std::runtime_error);
}

TEST(Utils, DecryptStringGcmAadMismatch) {
  std::string text = "hello gcm";
  std::array<uint8_t, 16> key = {0};
  std::vector<uint8_t> aad = {1, 2, 3};
  auto enc = aes_cpp::utils::encrypt_gcm(text, key, aad);
  aad[0] ^= 0x01;
  EXPECT_THROW(aes_cpp::utils::decrypt_gcm(enc, key, aad), std::runtime_error);
}

int main(int argc, char *argv[]) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif
